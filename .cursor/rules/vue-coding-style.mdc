---
alwaysApply: true
---

# Memoca Vue コーディングスタイル

## 🎯 基本原則

### 1. 簡素な実装
- **1liner**: 可能な限り1行で記述
- **ガード句**: 早期リターンを使用してネストを避ける
- **簡潔性**: 冗長なコードを避ける

### 2. コンポーネント設計
- **単一責任**: 1つのコンポーネントは1つの責任を持つ
- **再利用性**: 汎用的なコンポーネントを作成
- **プロップス**: 適切なプロップス設計

### 3. コメント・ログの最小化
- **コメント**: 必要最小限のみ記述
- **console.log**: デバッグ時のみ使用、本番コードでは削除

### 4. PrimeVueの積極的活用
- **コンポーネント**: PrimeVueのコンポーネントを積極的に使用
- **一貫性**: 統一されたUIコンポーネントで一貫したデザイン
- **効率性**: 既存のコンポーネントを活用して開発効率を向上

## 📝 Vueの書き方

### PrimeVueコンポーネントの活用

#### 主要コンポーネント一覧
```typescript
// フォーム系
Button          // ボタン - クリックアクション
InputText       // テキスト入力 - 単一行テキスト
Textarea        // テキストエリア - 複数行テキスト
Dropdown        // ドロップダウン - 選択肢から1つ選択
MultiSelect     // マルチセレクト - 複数選択
Checkbox        // チェックボックス - 真偽値入力
RadioButton     // ラジオボタン - 排他的選択
Calendar        // カレンダー - 日付選択
Password        // パスワード入力 - パスワード専用入力

// データ表示系
DataTable       // データテーブル - 表形式データ表示
Card            // カード - コンテンツのグループ化
Panel           // パネル - コンテンツの区切り
Divider         // 区切り線 - 視覚的分離
Badge           // バッジ - ステータス表示
Tag             // タグ - ラベル表示
Chip            // チップ - 小さな情報表示

// ナビゲーション系
Menu            // メニュー - ナビゲーション
Menubar         // メニューバー - 水平メニュー
Breadcrumb      // パンくずリスト - 階層ナビゲーション
TabView         // タブ - コンテンツ切り替え
Accordion       // アコーディオン - 折りたたみコンテンツ
Steps           // ステップ - 段階的プロセス

// フィードバック系
Dialog          // ダイアログ - モーダル表示
Toast           // トースト - 通知メッセージ
ProgressBar     // プログレスバー - 進捗表示
Skeleton        // スケルトン - ローディング表示
ProgressSpinner // スピナー - ローディング表示

// レイアウト系
Splitter        // スプリッター - 分割レイアウト
ScrollPanel     // スクロールパネル - スクロール可能領域
Toolbar         // ツールバー - アクションボタン群
```

#### ❌ 悪い例 - 独自コンポーネントの過度な使用
```vue
<template>
  <div>
    <!-- 独自のボタンコンポーネント -->
    <CustomButton @click="handleClick">クリック</CustomButton>
    
    <!-- 独自の入力コンポーネント -->
    <CustomInput v-model="value" placeholder="入力してください" />
    
    <!-- 独自のモーダルコンポーネント -->
    <CustomModal v-model:visible="showModal">
      <p>コンテンツ</p>
    </CustomModal>
  </div>
</template>
```

#### ✅ 良い例 - PrimeVueコンポーネントの活用
```vue
<template>
  <div>
    <!-- PrimeVueのButtonコンポーネント -->
    <Button label="クリック" @click="handleClick" />
    
    <!-- PrimeVueのInputTextコンポーネント -->
    <InputText v-model="value" placeholder="入力してください" />
    
    <!-- PrimeVueのDialogコンポーネント -->
    <Dialog v-model:visible="showModal" header="タイトル">
      <p>コンテンツ</p>
    </Dialog>
  </div>
</template>
```

### コンポーネントの書き方

#### ❌ 悪い例
```vue
<template>
  <div>
    <div v-if="user">
      <div v-if="user.isAuthenticated">
        <div v-if="user.profile">
          <h1>{{ user.profile.name }}</h1>
        </div>
        <div v-else>
          <p>プロフィールが見つかりません</p>
        </div>
      </div>
      <div v-else>
        <p>ログインしてください</p>
      </div>
    </div>
    <div v-else>
      <p>ユーザー情報がありません</p>
    </div>
  </div>
</template>

<script setup lang="ts">
// 過度なネスト
const user = ref(null);
const loading = ref(false);
const error = ref(null);

// 冗長な処理
async function fetchUser() {
  try {
    loading.value = true;
    error.value = null;
    
    if (!userId.value) {
      error.value = 'ユーザーIDが必要です';
      return;
    }
    
    const response = await api.getUser(userId.value);
    user.value = response.data;
  } catch (err) {
    error.value = err.message;
  } finally {
    loading.value = false;
  }
}
</script>
```

#### ✅ 良い例
```vue
<template>
  <div>
    <h1 v-if="user?.isAuthenticated && user?.profile">{{ user.profile.name }}</h1>
    <p v-else-if="!user">ユーザー情報がありません</p>
    <p v-else-if="!user.isAuthenticated">ログインしてください</p>
    <p v-else>プロフィールが見つかりません</p>
  </div>
</template>

<script setup lang="ts">
// 簡潔な実装
const user = ref<User | null>(null);
const loading = ref(false);
const error = ref<string | null>(null);

// ガード句の活用
const fetchUser = async (userId: string) => {
  if (!userId) return;
  
  loading.value = true;
  error.value = null;
  
  try {
    const response = await api.getUser(userId);
    user.value = response.data;
  } catch (err) {
    error.value = err.message;
  } finally {
    loading.value = false;
  }
};
</script>
```

### Composablesの書き方

#### ❌ 悪い例
```typescript
export function useAuth() {
  const user = ref(null);
  const loading = ref(false);
  const error = ref(null);

  async function login(email: string, password: string) {
    try {
      loading.value = true;
      error.value = null;
      
      if (!email) {
        error.value = 'メールアドレスが必要です';
        return;
      }
      
      if (!password) {
        error.value = 'パスワードが必要です';
        return;
      }
      
      const result = await signInWithEmailAndPassword(auth, email, password);
      user.value = result.user;
    } catch (err) {
      error.value = err.message;
    } finally {
      loading.value = false;
    }
  }

  return { user, loading, error, login };
}
```

#### ✅ 良い例
```typescript
export function useAuth() {
  const user = ref<User | null>(null);
  const loading = ref(false);
  const error = ref<string | null>(null);

  const login = async (email: string, password: string) => {
    if (!email || !password) return;
    
    loading.value = true;
    error.value = null;
    
    try {
      const result = await signInWithEmailAndPassword(auth, email, password);
      user.value = result.user;
    } catch (err) {
      error.value = err.message;
    } finally {
      loading.value = false;
    }
  };

  return { user, loading, error, login };
}
```

### プロップスの書き方

#### ❌ 悪い例
```vue
<script setup lang="ts">
// 型定義が不適切
const props = defineProps({
  title: String,
  items: Array,
  onSelect: Function
});

// プロップスの使用が不適切
const handleSelect = (item: any) => {
  if (props.onSelect) {
    props.onSelect(item);
  }
};
</script>
```

#### ✅ 良い例
```vue
<script setup lang="ts">
// 適切な型定義
interface Props {
  title: string;
  items: Item[];
  onSelect?: (item: Item) => void;
}

const props = defineProps<Props>();

// プロップスの使用が適切
const handleSelect = (item: Item) => {
  props.onSelect?.(item);
};
</script>
```

## 🔧 実装パターン

### 1. 条件分岐の簡素化
```vue
<template>
  <!-- 複雑な条件を関数に分離 -->
  <div v-if="isValidUser(user)">
    <h1>{{ user.profile.name }}</h1>
  </div>
  <div v-else>
    <p>ユーザー情報が無効です</p>
  </div>
</template>

<script setup lang="ts">
const isValidUser = (user: User) => 
  user?.isAuthenticated && 
  user?.profile?.name;
</script>
```

### 2. イベントハンドリングの簡素化
```vue
<template>
  <!-- インラインで簡潔に記述 -->
  <button @click="handleClick">クリック</button>
  
  <!-- 複数のイベントを処理 -->
  <input 
    @input="handleInput"
    @keyup.enter="handleSubmit"
    @blur="handleBlur"
  />
</template>

<script setup lang="ts">
const handleClick = () => {
  // 処理
};

const handleInput = (event: Event) => {
  const target = event.target as HTMLInputElement;
  // 処理
};

const handleSubmit = () => {
  // 処理
};

const handleBlur = () => {
  // 処理
};
</script>
```

### 3. リアクティブデータの管理
```vue
<script setup lang="ts">
// 適切なリアクティブデータの管理
const count = ref(0);
const items = ref<Item[]>([]);
const loading = ref(false);

// 計算プロパティの活用
const filteredItems = computed(() => 
  items.value.filter(item => item.isActive)
);

// ウォッチャーの活用
watch(count, (newCount, oldCount) => {
  console.log(`Count changed from ${oldCount} to ${newCount}`);
});

// 即座に実行されるウォッチャー
watchEffect(() => {
  console.log(`Current count: ${count.value}`);
});
</script>
```

### 4. ライフサイクルフックの活用
```vue
<script setup lang="ts">
// 適切なライフサイクルフックの使用
onMounted(() => {
  // 初期化処理
  fetchData();
});

onUnmounted(() => {
  // クリーンアップ処理
  cleanup();
});

// 依存関係の監視
watch([userId, filter], () => {
  fetchData();
}, { immediate: true });
</script>
```

## 🚫 避けるべきパターン

### 1. 過度なネスト
```vue
<!-- ❌ 避ける -->
<template>
  <div v-if="user">
    <div v-if="user.isAuthenticated">
      <div v-if="user.profile">
        <h1>{{ user.profile.name }}</h1>
      </div>
    </div>
  </div>
</template>

<!-- ✅ 推奨 -->
<template>
  <div>
    <h1 v-if="user?.isAuthenticated && user?.profile">
      {{ user.profile.name }}
    </h1>
  </div>
</template>
```

### 2. 冗長なコメント
```vue
<!-- ❌ 避ける -->
<template>
  <!-- ユーザー情報を表示 -->
  <div v-if="user">
    <!-- ユーザー名を表示 -->
    <h1>{{ user.name }}</h1>
  </div>
</template>

<!-- ✅ 推奨 -->
<template>
  <div v-if="user">
    <h1>{{ user.name }}</h1>
  </div>
</template>
```

### 3. 不要なconsole.log
```vue
<script setup lang="ts">
// ❌ 避ける
const fetchData = async () => {
  console.log('データを取得中...');
  const response = await api.getData();
  console.log('データ取得完了:', response);
  return response;
};

// ✅ 推奨
const fetchData = async () => {
  const response = await api.getData();
  return response;
};
</script>
```

### 4. 不適切なプロップスの使用
```vue
<!-- ❌ 避ける -->
<template>
  <div>
    <input v-model="props.title" />
    <button @click="props.onSave">保存</button>
  </div>
</template>

<!-- ✅ 推奨 -->
<template>
  <div>
    <input v-model="localTitle" />
    <button @click="handleSave">保存</button>
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{
  title: string;
  onSave: () => void;
}>();

const localTitle = ref(props.title);

const handleSave = () => {
  props.onSave();
};
</script>
```

## 📋 チェックリスト

### コードレビュー時
- [ ] 1linerで記述できる箇所は1行で記述
- [ ] ガード句を使用してネストを避けている
- [ ] コンポーネントが単一責任を持っている
- [ ] プロップスの型定義が適切
- [ ] 不要なコメントを削除
- [ ] console.logを削除
- [ ] 条件分岐が簡潔
- [ ] イベントハンドリングが適切
- [ ] PrimeVueコンポーネントを積極的に使用している
- [ ] 独自コンポーネントの過度な使用を避けている

### リファクタリング時
- [ ] ネストを3レベル以下に抑制
- [ ] 早期リターンを活用
- [ ] 三項演算子・論理演算子を活用
- [ ] 冗長な処理を統合
- [ ] コンポーネントの責任を明確化
- [ ] 独自コンポーネントをPrimeVueコンポーネントに置き換え
- [ ] PrimeVueの機能を最大限活用

## 🎯 ベストプラクティス

1. **可読性**: コードが自己説明的である
2. **簡潔性**: 必要最小限のコードで実装
3. **保守性**: 変更が容易な構造
4. **パフォーマンス**: 不要な再レンダリングを避ける
5. **一貫性**: プロジェクト全体で統一されたスタイル
6. **再利用性**: 汎用的なコンポーネントを作成
7. **PrimeVue活用**: 既存のコンポーネントを最大限活用
8. **UI統一**: PrimeVueで一貫したデザインシステム

## 💡 実装のヒント

### 1. 条件分岐の簡素化
```vue
<template>
  <!-- 複雑な条件を関数に分離 -->
  <div v-if="isValidUser(user)">
    <h1>{{ user.profile.name }}</h1>
  </div>
</template>

<script setup lang="ts">
const isValidUser = (user: User) => 
  user?.isAuthenticated && 
  user?.profile?.name;
</script>
```

### 2. プロップスの適切な使用
```vue
<script setup lang="ts">
// プロップスの型定義
interface Props {
  title: string;
  items: Item[];
  onSelect?: (item: Item) => void;
}

const props = defineProps<Props>();

// プロップスの使用
const handleSelect = (item: Item) => {
  props.onSelect?.(item);
};
</script>
```

### 3. リアクティブデータの管理
```vue
<script setup lang="ts">
// 適切なリアクティブデータの管理
const count = ref(0);
const items = ref<Item[]>([]);

// 計算プロパティの活用
const filteredItems = computed(() => 
  items.value.filter(item => item.isActive)
);
</script>
```

### 4. イベントハンドリングの簡素化
```vue
<template>
  <!-- インラインで簡潔に記述 -->
  <button @click="handleClick">クリック</button>
</template>

<script setup lang="ts">
const handleClick = () => {
  // 処理
};
</script>
```

### 5. PrimeVueコンポーネントの活用
```vue
<template>
  <!-- フォーム系コンポーネント -->
  <div class="form">
    <InputText v-model="name" placeholder="名前を入力" />
    <Dropdown v-model="selected" :options="options" />
    <Button label="保存" @click="save" />
  </div>
  
  <!-- データ表示系コンポーネント -->
  <DataTable :value="items" :paginator="true" :rows="10">
    <Column field="name" header="名前"></Column>
    <Column field="email" header="メール"></Column>
  </DataTable>
  
  <!-- フィードバック系コンポーネント -->
  <Toast />
  <Dialog v-model:visible="showDialog" header="確認">
    <p>本当に削除しますか？</p>
  </Dialog>
</template>
```

このVueコーディングスタイルに従うことで、保守性が高く、読みやすいVueコンポーネントを書くことができます。