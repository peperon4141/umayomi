---
alwaysApply: true
---

# Memoca TypeScript コーディングスタイル

## 🎯 基本原則

### 1. 簡素な実装
- **1liner**: 可能な限り1行で記述
- **ガード句**: 早期リターンを使用してネストを避ける
- **簡潔性**: 冗長なコードを避ける

### 2. 型安全性の重視
- **型定義**: 適切な型定義を使用
- **型推論**: TypeScriptの型推論を活用
- **型ガード**: 実行時の型チェックを適切に実装

### 3. コメント・ログの最小化
- **コメント**: 必要最小限のみ記述
- **console.log**: デバッグ時のみ使用、本番コードでは削除

### 4. 定数定義と変数削減
- **定数**: マジックナンバーや文字列は定数として定義
- **変数削減**: 不要な変数を避け、直接的な実装を優先
- **再利用**: 共通処理は関数として抽出

## 📝 TypeScriptの書き方

### 関数の書き方

#### ❌ 悪い例
```typescript
function validateUser(user: User): boolean {
  if (user) {
    if (user.email) {
      if (user.email.includes('@')) {
        if (user.password) {
          if (user.password.length >= 8) {
            return true;
          } else {
            return false;
          }
        } else {
          return false;
        }
      } else {
        return false;
      }
    } else {
      return false;
    }
  } else {
    return false;
  }
}
```

#### ✅ 良い例
```typescript
function validateUser(user: User): boolean {
  if (!user) return false;
  if (!user.email?.includes('@')) return false;
  if (!user.password || user.password.length < 8) return false;
  return true;
}
```

### 型定義の書き方

#### ❌ 悪い例
```typescript
// 型定義が不適切
interface User {
  id: any;
  name: any;
  email: any;
  profile: any;
}

// 型ガードが不適切
function isUser(obj: any): obj is User {
  return obj && obj.id && obj.name;
}
```

#### ✅ 良い例
```typescript
// 適切な型定義
interface User {
  id: string;
  name: string;
  email: string;
  profile?: UserProfile;
}

// 適切な型ガード
function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    typeof (obj as User).id === 'string' &&
    typeof (obj as User).name === 'string' &&
    typeof (obj as User).email === 'string'
  );
}
```

### 非同期処理の書き方

#### ❌ 悪い例
```typescript
// Promiseチェーンの乱用
function fetchUser(id: string): Promise<User> {
  return fetch(`/api/users/${id}`)
    .then(response => {
      if (response.ok) {
        return response.json();
      } else {
        throw new Error('Failed to fetch user');
      }
    })
    .then(data => {
      return data;
    })
    .catch(error => {
      console.error('Error:', error);
      throw error;
    });
}
```

#### ✅ 良い例
```typescript
// async/await の活用
async function fetchUser(id: string): Promise<User> {
  try {
    const response = await fetch(`/api/users/${id}`);
    if (!response.ok) throw new Error('Failed to fetch user');
    return await response.json();
  } catch (error) {
    console.error('Error:', error);
    throw error;
  }
}
```

## 🔧 実装パターン

### 1. 定数定義と変数削減

#### ❌ 悪い例
```typescript
// マジックナンバーと冗長な変数
function processData() {
  const data = getData();
  const processedData = data.map(item => {
    const transformedItem = transform(item);
    return transformedItem;
  });
  
  localStorage.setItem('user-data', JSON.stringify(processedData));
  document.getElementById('result').textContent = processedData.length.toString();
}
```

#### ✅ 良い例
```typescript
// 定数定義と変数削減
const STORAGE_KEY = 'user-data';
const RESULT_ELEMENT_ID = 'result';

function processData() {
  const processedData = getData().map(transform);
  localStorage.setItem(STORAGE_KEY, JSON.stringify(processedData));
  document.getElementById(RESULT_ELEMENT_ID).textContent = processedData.length.toString();
}
```

### 2. ガード句の活用
```typescript
// 早期リターンでネストを避ける
function processData(data: unknown): ProcessedData[] {
  if (!data) return [];
  if (!Array.isArray(data)) return [];
  if (data.length === 0) return [];
  
  return data.map(item => transform(item));
}
```

### 2. 条件分岐の簡素化
```typescript
// 三項演算子の活用
const status = user.isActive ? 'active' : 'inactive';

// 論理演算子の活用
const displayName = user.name || user.email || 'Unknown';

// オプショナルチェーニングの活用
const profileName = user?.profile?.name;
```

### 3. 配列・オブジェクト操作の簡素化
```typescript
// 配列操作
const activeUsers = users.filter(user => user.isActive);
const userNames = users.map(user => user.name);

// オブジェクト操作
const userData = { id: user.id, name: user.name, email: user.email };

// スプレッド演算子の活用
const updatedUser = { ...user, lastLogin: new Date() };

// 分割代入の活用
const { name, email } = user;
```

### 4. 型安全性の確保
```typescript
// 型ガードの活用
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

// ユニオン型の活用
type Status = 'pending' | 'approved' | 'rejected';

// ジェネリクスの活用
function createResponse<T>(data: T): ApiResponse<T> {
  return { success: true, data };
}
```

## 🚫 避けるべきパターン

### 1. 過度なネスト
```typescript
// ❌ 避ける
if (condition1) {
  if (condition2) {
    if (condition3) {
      // 処理
    }
  }
}

// ✅ 推奨
if (!condition1) return;
if (!condition2) return;
if (!condition3) return;
// 処理
```

### 2. any型の乱用
```typescript
// ❌ 避ける
function processData(data: any): any {
  return data.map((item: any) => item.value);
}

// ✅ 推奨
function processData<T>(data: T[]): T[] {
  return data.map(item => item);
}
```

### 3. 冗長なコメント
```typescript
// ❌ 避ける
// ユーザーを取得する関数
function getUser(): User {
  // ユーザーIDを取得
  const userId = getCurrentUserId();
  // ユーザー情報を取得
  const user = fetchUser(userId);
  // ユーザー情報を返す
  return user;
}

// ✅ 推奨
function getUser(): User {
  const userId = getCurrentUserId();
  return fetchUser(userId);
}
```

### 4. 不要なconsole.log
```typescript
// ❌ 避ける
function processData(data: any[]) {
  console.log('データを処理中:', data);
  const result = data.map(item => {
    console.log('アイテム処理中:', item);
    return transform(item);
  });
  console.log('処理完了:', result);
  return result;
}

// ✅ 推奨
function processData(data: unknown[]): ProcessedData[] {
  return data.map(transform);
}
```

### 5. マジックナンバーと冗長な変数
```typescript
// ❌ 避ける
function calculatePrice(price: number) {
  const taxRate = 0.1;
  const tax = price * taxRate;
  const totalPrice = price + tax;
  return totalPrice;
}

function saveUser(user: User) {
  const userData = JSON.stringify(user);
  localStorage.setItem('user-data', userData);
  const saved = localStorage.getItem('user-data');
  return saved !== null;
}

// ✅ 推奨
const TAX_RATE = 0.1;
const USER_STORAGE_KEY = 'user-data';

function calculatePrice(price: number) {
  return price * (1 + TAX_RATE);
}

function saveUser(user: User) {
  localStorage.setItem(USER_STORAGE_KEY, JSON.stringify(user));
  return localStorage.getItem(USER_STORAGE_KEY) !== null;
}
```

## 📋 チェックリスト

### コードレビュー時
- [ ] 1linerで記述できる箇所は1行で記述
- [ ] ガード句を使用してネストを避けている
- [ ] 適切な型定義を使用している
- [ ] any型を避けている
- [ ] 不要なコメントを削除
- [ ] console.logを削除
- [ ] 条件分岐が簡潔
- [ ] 関数が単一責任
- [ ] マジックナンバーを定数として定義
- [ ] 不要な変数を削除
- [ ] 共通処理を関数として抽出

### リファクタリング時
- [ ] ネストを3レベル以下に抑制
- [ ] 早期リターンを活用
- [ ] 三項演算子・論理演算子を活用
- [ ] 冗長な処理を統合
- [ ] 型安全性を向上
- [ ] マジックナンバーを定数に置き換え
- [ ] 不要な変数を削除
- [ ] 共通処理を関数として抽出

## 🎯 ベストプラクティス

1. **可読性**: コードが自己説明的である
2. **簡潔性**: 必要最小限のコードで実装
3. **保守性**: 変更が容易な構造
4. **パフォーマンス**: 不要な処理を避ける
5. **一貫性**: プロジェクト全体で統一されたスタイル
6. **型安全性**: TypeScriptの型システムを最大限活用

## 💡 実装のヒント

### 1. 条件分岐の簡素化
```typescript
// 複雑な条件を関数に分離
const isValidUser = (user: User) => 
  user?.email?.includes('@') && 
  user?.password?.length >= 8;

if (isValidUser(user)) {
  // 処理
}
```

### 2. オブジェクト操作の簡素化
```typescript
// スプレッド演算子の活用
const updatedUser = { ...user, lastLogin: new Date() };

// 分割代入の活用
const { name, email } = user;
```

### 3. 配列操作の簡素化
```typescript
// チェーンメソッドの活用
const activeUserNames = users
  .filter(user => user.isActive)
  .map(user => user.name)
  .filter(name => name);
```

### 4. エラーハンドリングの簡素化
```typescript
// try-catch の最小化
const safeExecute = <T>(fn: () => T): T | null => {
  try {
    return fn();
  } catch {
    return null;
  }
};
```

### 5. 型ガードの活用
```typescript
// 型ガード関数
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

// 使用例
if (isString(value)) {
  // valueはstring型として扱える
  console.log(value.toUpperCase());
}
```

このTypeScriptコーディングスタイルに従うことで、保守性が高く、読みやすいコードを書くことができます。