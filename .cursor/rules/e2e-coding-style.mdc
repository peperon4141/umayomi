---
alwaysApply: true
---

# Memoca E2Eテスト コーディングスタイル

## 🎯 基本原則

### 1. 簡素な実装
- **1liner**: 可能な限り1行で記述
- **ガード句**: 早期リターンを使用してネストを避ける
- **簡潔性**: 冗長なコードを避ける

### 2. テストの可読性
- **テストケース名**: 日本語で具体的に記述
- **PageObject**: 適切なPageObjectパターンの使用
- **アサーション**: 明確で分かりやすいアサーション

### 3. 保守性の重視
- **再利用性**: 共通のテストヘルパーを作成
- **独立性**: 各テストは独立して実行可能
- **安定性**: テストが安定して実行される

## 📝 E2Eテストの書き方

### テストケースの書き方

#### ❌ 悪い例
```typescript
// 不適切なテストケース名
test('test1', async ({ page }) => {
  await page.goto('/');
  await page.click('button');
  await page.waitForSelector('.result');
  const text = await page.textContent('.result');
  expect(text).toBe('Success');
});

// 過度なネスト
test('複雑なテスト', async ({ page }) => {
  await page.goto('/');
  
  if (await page.isVisible('.login-form')) {
    await page.fill('input[type="email"]', 'test@example.com');
    await page.fill('input[type="password"]', 'password');
    await page.click('button[type="submit"]');
    
    if (await page.isVisible('.dashboard')) {
      await page.click('.create-button');
      
      if (await page.isVisible('.create-form')) {
        await page.fill('input[name="title"]', 'テストタイトル');
        await page.click('button[type="submit"]');
        
        if (await page.isVisible('.success-message')) {
          const message = await page.textContent('.success-message');
          expect(message).toBe('作成しました');
        }
      }
    }
  }
});
```

#### ✅ 良い例
```typescript
// 適切なテストケース名
test('ログインページに遷移できる', async ({ page }) => {
  await page.goto('/');
  await page.click('text=ログイン');
  await expect(page).toHaveURL('/login');
});

// 簡潔なテスト
test('デッキを作成できる', async ({ page }) => {
  await loginUser(page, 'test@example.com', 'password');
  await page.click('text=デッキを作成');
  await page.fill('input[id="title"]', 'テストデッキ');
  await page.click('button:has-text("作成")');
  await expect(page.locator('text=テストデッキ')).toBeVisible();
});
```

### PageObjectの書き方

#### ❌ 悪い例
```typescript
// 不適切なPageObject
export class LoginPage {
  constructor(private page: Page) {}

  async login(email: string, password: string) {
    await this.page.goto('/login');
    await this.page.fill('input[type="email"]', email);
    await this.page.fill('input[type="password"]', password);
    await this.page.click('button[type="submit"]');
    
    // アサーションをPageObjectに含める（不適切）
    await expect(this.page.locator('.dashboard')).toBeVisible();
  }
}
```

#### ✅ 良い例
```typescript
// 適切なPageObject
export class LoginPage {
  constructor(private page: Page) {}

  get emailInput() {
    return this.page.locator('input[type="email"]');
  }

  get passwordInput() {
    return this.page.locator('input[type="password"]');
  }

  get submitButton() {
    return this.page.locator('button[type="submit"]');
  }

  async login(email: string, password: string) {
    await this.page.goto('/login');
    await this.emailInput.fill(email);
    await this.passwordInput.fill(password);
    await this.submitButton.click();
  }
}
```

## 🔧 実装パターン

### 1. テストヘルパーの活用
```typescript
// 共通のテストヘルパー
export async function loginUser(page: Page, email: string, password: string) {
  await page.goto('/login');
  await page.fill('input[type="email"]', email);
  await page.fill('input[type="password"]', password);
  await page.click('button[type="submit"]');
  await page.waitForURL('/dashboard');
}

export async function createTestDeck(page: Page, title: string) {
  await page.click('text=デッキを作成');
  await page.fill('input[id="title"]', title);
  await page.click('button:has-text("作成")');
}
```

### 2. 適切な待機処理
```typescript
// 適切な待機処理
test('データが読み込まれるまで待機', async ({ page }) => {
  await page.goto('/dashboard');
  
  // 特定の要素が表示されるまで待機
  await page.waitForSelector('.data-loaded');
  
  // URLの変更を待機
  await page.waitForURL('/dashboard');
  
  // ネットワークリクエストの完了を待機
  await page.waitForLoadState('networkidle');
});
```

### 3. データのクリーンアップ
```typescript
// テスト後のクリーンアップ
test.beforeEach(async ({ page }) => {
  // テスト前のセットアップ
  await page.goto('/');
  await loginUser(page, 'test@example.com', 'password');
});

test.afterEach(async ({ page }) => {
  // テスト後のクリーンアップ
  await page.goto('/settings');
  await page.click('text=データを削除');
  await page.click('button:has-text("確認")');
});
```

## 🚫 避けるべきパターン

### 1. 不適切な待機処理
```typescript
// ❌ 避ける - 固定時間待機
test('不適切な待機', async ({ page }) => {
  await page.goto('/');
  await page.waitForTimeout(5100); // 固定時間待機
  await page.click('button');
});

// ✅ 推奨 - 条件待機
test('適切な待機', async ({ page }) => {
  await page.goto('/');
  await page.waitForSelector('button');
  await page.click('button');
});
```

### 2. 過度なネスト
```typescript
// ❌ 避ける
test('複雑なテスト', async ({ page }) => {
  await page.goto('/');
  
  if (await page.isVisible('.login-form')) {
    await page.fill('input[type="email"]', 'test@example.com');
    await page.fill('input[type="password"]', 'password');
    await page.click('button[type="submit"]');
    
    if (await page.isVisible('.dashboard')) {
      await page.click('.create-button');
      
      if (await page.isVisible('.create-form')) {
        await page.fill('input[name="title"]', 'テストタイトル');
        await page.click('button[type="submit"]');
      }
    }
  }
});

// ✅ 推奨
test('簡潔なテスト', async ({ page }) => {
  await loginUser(page, 'test@example.com', 'password');
  await createTestDeck(page, 'テストタイトル');
  await expect(page.locator('text=テストタイトル')).toBeVisible();
});
```

### 3. 不適切なセレクター
```typescript
// ❌ 避ける - 不安定なセレクター
test('不安定なセレクター', async ({ page }) => {
  await page.click('div:nth-child(3) > button:nth-child(2)');
  await page.fill('input[class*="form-control"]', 'test');
});

// ✅ 推奨 - 安定したセレクター
test('安定したセレクター', async ({ page }) => {
  await page.click('button:has-text("作成")');
  await page.fill('input[id="title"]', 'test');
});
```

## 📋 チェックリスト

### コードレビュー時
- [ ] テストケース名が日本語で具体的
- [ ] PageObjectが適切に使用されている
- [ ] アサーションが明確で分かりやすい
- [ ] 待機処理が適切
- [ ] セレクターが安定している
- [ ] テストが独立して実行可能

### リファクタリング時
- [ ] 重複するテストコードを統合
- [ ] テストヘルパーを作成
- [ ] PageObjectを改善
- [ ] セレクターを安定化
- [ ] 待機処理を最適化

## 🎯 ベストプラクティス

1. **可読性**: テストが自己説明的である
2. **簡潔性**: 必要最小限のコードで実装
3. **保守性**: 変更が容易な構造
4. **安定性**: テストが安定して実行される
5. **独立性**: 各テストが独立して実行可能
6. **再利用性**: 共通のテストヘルパーを活用

## 💡 実装のヒント

### 1. テストケース名の命名規則
```typescript
// 具体的で分かりやすいテストケース名
test('ログインページに遷移できる', async ({ page }) => {
  // テスト実装
});

test('有効な認証情報でログインできる', async ({ page }) => {
  // テスト実装
});

test('無効な認証情報でログインに失敗する', async ({ page }) => {
  // テスト実装
});
```

### 2. PageObjectの設計
```typescript
// 適切なPageObjectの設計
export class DashboardPage {
  constructor(private page: Page) {}

  // 要素の取得
  get createButton() {
    return this.page.locator('button:has-text("作成")');
  }

  get deckList() {
    return this.page.locator('.deck-list');
  }

  // 操作の実行
  async createDeck(title: string) {
    await this.createButton.click();
    await this.page.fill('input[id="title"]', title);
    await this.page.click('button:has-text("作成")');
  }

  // データの取得
  async getDeckTitles() {
    return await this.deckList.locator('.deck-title').allTextContents();
  }
}
```

### 3. アサーションの書き方
```typescript
// 明確で分かりやすいアサーション
test('デッキが作成される', async ({ page }) => {
  await createTestDeck(page, 'テストデッキ');
  
  // 要素が表示されることを確認
  await expect(page.locator('text=テストデッキ')).toBeVisible();
  
  // 要素のテキストを確認
  await expect(page.locator('.deck-title')).toHaveText('テストデッキ');
  
  // 要素の数が正しいことを確認
  await expect(page.locator('.deck-item')).toHaveCount(1);
});
```

このE2Eテストコーディングスタイルに従うことで、保守性が高く、読みやすいテストを書くことができます。