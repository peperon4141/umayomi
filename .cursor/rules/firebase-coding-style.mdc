---
alwaysApply: true
---

# Memoca Firebase コーディングスタイル

## 🎯 基本原則

### 1. 簡素な実装
- **1liner**: 可能な限り1行で記述
- **ガード句**: 早期リターンを使用してネストを避ける
- **簡潔性**: 冗長なコードを避ける

### 2. セキュリティの重視
- **Security Rules**: 適切なセキュリティルールの設定
- **認証**: 適切な認証状態の確認
- **権限**: 最小権限の原則

### 3. パフォーマンスの最適化
- **クエリ**: 効率的なクエリの作成
- **インデックス**: 適切なインデックスの設定
- **キャッシュ**: 適切なキャッシュ戦略

## 📝 Firebaseの書き方

### Firestoreの書き方

#### ❌ 悪い例
```typescript
// 不適切なクエリ
async function getUsers() {
  try {
    const snapshot = await getDocs(collection(db, 'users'));
    const users = [];
    snapshot.forEach(doc => {
      const userData = doc.data();
      if (userData.isActive) {
        users.push({
          id: doc.id,
          ...userData
        });
      }
    });
    return users;
  } catch (error) {
    console.error('Error getting users:', error);
    return [];
  }
}

// 不適切なデータ更新
async function updateUser(userId: string, data: any) {
  try {
    await updateDoc(doc(db, 'users', userId), data);
    return true;
  } catch (error) {
    console.error('Error updating user:', error);
    return false;
  }
}
```

#### ✅ 良い例
```typescript
// 適切なクエリ
async function getActiveUsers(): Promise<User[]> {
  try {
    const q = query(
      collection(db, 'users'),
      where('isActive', '==', true)
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    } as User));
  } catch (error) {
    console.error('Error getting active users:', error);
    throw error;
  }
}

// 適切なデータ更新
async function updateUser(userId: string, data: Partial<User>): Promise<void> {
  if (!userId || !data) throw new Error('Invalid parameters');
  
  try {
    await updateDoc(doc(db, 'users', userId), data);
  } catch (error) {
    console.error('Error updating user:', error);
    throw error;
  }
}
```

### Authenticationの書き方

#### ❌ 悪い例
```typescript
// 不適切な認証処理
async function login(email: string, password: string) {
  try {
    const result = await signInWithEmailAndPassword(auth, email, password);
    const user = result.user;
    if (user) {
      const token = await user.getIdToken();
      localStorage.setItem('token', token);
      return user;
    }
  } catch (error) {
    console.error('Login error:', error);
    return null;
  }
}

// 不適切な認証状態の確認
function checkAuth() {
  const user = auth.currentUser;
  if (user) {
    return true;
  } else {
    return false;
  }
}
```

#### ✅ 良い例
```typescript
// 適切な認証処理
async function login(email: string, password: string): Promise<User> {
  if (!email || !password) throw new Error('Email and password are required');
  
  try {
    const result = await signInWithEmailAndPassword(auth, email, password);
    return result.user;
  } catch (error) {
    console.error('Login error:', error);
    throw error;
  }
}

// 適切な認証状態の確認
function isAuthenticated(): boolean {
  return !!auth.currentUser;
}
```

### Storageの書き方

#### ❌ 悪い例
```typescript
// 不適切なファイルアップロード
async function uploadFile(file: File, path: string) {
  try {
    const storageRef = ref(storage, path);
    const snapshot = await uploadBytes(storageRef, file);
    const downloadURL = await getDownloadURL(snapshot.ref);
    return downloadURL;
  } catch (error) {
    console.error('Upload error:', error);
    return null;
  }
}
```

#### ✅ 良い例
```typescript
// 適切なファイルアップロード
async function uploadFile(file: File, path: string): Promise<string> {
  if (!file || !path) throw new Error('File and path are required');
  
  try {
    const storageRef = ref(storage, path);
    const snapshot = await uploadBytes(storageRef, file);
    return await getDownloadURL(snapshot.ref);
  } catch (error) {
    console.error('Upload error:', error);
    throw error;
  }
}
```

## 🔧 実装パターン

### 1. エラーハンドリングの統一
```typescript
// 統一されたエラーハンドリング
async function handleFirebaseError<T>(
  operation: () => Promise<T>
): Promise<T> {
  try {
    return await operation();
  } catch (error) {
    console.error('Firebase operation failed:', error);
    throw error;
  }
}

// 使用例
const getUsers = () => handleFirebaseError(async () => {
  const snapshot = await getDocs(collection(db, 'users'));
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
});
```

### 2. 型安全性の確保
```typescript
// 適切な型定義
interface User {
  id: string;
  name: string;
  email: string;
  isActive: boolean;
  createdAt: Timestamp;
}

// 型安全なクエリ
async function getUserById(id: string): Promise<User | null> {
  try {
    const docRef = doc(db, 'users', id);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() } as User;
    }
    return null;
  } catch (error) {
    console.error('Error getting user:', error);
    throw error;
  }
}
```

### 3. リアルタイムリスナーの管理
```typescript
// 適切なリスナーの管理
function useUsers() {
  const users = ref<User[]>([]);
  const loading = ref(false);
  const error = ref<string | null>(null);
  
  let unsubscribe: (() => void) | null = null;
  
  const startListening = () => {
    if (unsubscribe) return;
    
    loading.value = true;
    error.value = null;
    
    const q = query(collection(db, 'users'), where('isActive', '==', true));
    
    unsubscribe = onSnapshot(q, 
      (snapshot) => {
        users.value = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        } as User));
        loading.value = false;
      },
      (err) => {
        error.value = err.message;
        loading.value = false;
      }
    );
  };
  
  const stopListening = () => {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = null;
    }
  };
  
  onUnmounted(() => {
    stopListening();
  });
  
  return { users, loading, error, startListening, stopListening };
}
```

### 4. バッチ操作の活用
```typescript
// 適切なバッチ操作
async function createMultipleUsers(users: Omit<User, 'id'>[]): Promise<void> {
  if (!users.length) return;
  
  const batch = writeBatch(db);
  
  users.forEach(userData => {
    const docRef = doc(collection(db, 'users'));
    batch.set(docRef, userData);
  });
  
  try {
    await batch.commit();
  } catch (error) {
    console.error('Error creating users:', error);
    throw error;
  }
}
```

## 🚫 避けるべきパターン

### 1. 不適切なセキュリティルール
```javascript
// ❌ 避ける - 過度に緩いルール
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if true;
    }
  }
}

// ✅ 推奨 - 適切なセキュリティルール
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
```

### 2. 不適切なクエリ
```typescript
// ❌ 避ける - 非効率なクエリ
async function getUsers() {
  const snapshot = await getDocs(collection(db, 'users'));
  return snapshot.docs
    .map(doc => doc.data())
    .filter(user => user.isActive);
}

// ✅ 推奨 - 効率的なクエリ
async function getActiveUsers() {
  const q = query(
    collection(db, 'users'),
    where('isActive', '==', true)
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => doc.data());
}
```

### 3. 不適切なエラーハンドリング
```typescript
// ❌ 避ける
async function getUser(id: string) {
  try {
    const doc = await getDoc(doc(db, 'users', id));
    return doc.data();
  } catch (error) {
    console.error('Error:', error);
    return null;
  }
}

// ✅ 推奨
async function getUser(id: string): Promise<User | null> {
  if (!id) throw new Error('User ID is required');
  
  try {
    const docRef = doc(db, 'users', id);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() } as User;
    }
    return null;
  } catch (error) {
    console.error('Error getting user:', error);
    throw error;
  }
}
```

### 4. 不適切な認証状態の確認
```typescript
// ❌ 避ける
function isLoggedIn() {
  return auth.currentUser !== null;
}

// ✅ 推奨
function isAuthenticated(): boolean {
  return !!auth.currentUser;
}

// より詳細な認証状態の確認
function getAuthState(): 'loading' | 'authenticated' | 'unauthenticated' {
  if (auth.currentUser) return 'authenticated';
  if (auth.currentUser === null) return 'unauthenticated';
  return 'loading';
}
```

## 📋 チェックリスト

### コードレビュー時
- [ ] セキュリティルールが適切に設定されている
- [ ] 認証状態の確認が適切
- [ ] エラーハンドリングが統一されている
- [ ] 型安全性が確保されている
- [ ] クエリが効率的
- [ ] リスナーが適切に管理されている
- [ ] バッチ操作が適切に使用されている

### リファクタリング時
- [ ] セキュリティルールを最適化
- [ ] クエリを効率化
- [ ] エラーハンドリングを統一
- [ ] 型定義を改善
- [ ] リスナーの管理を改善

## 🎯 ベストプラクティス

1. **セキュリティ**: 適切なセキュリティルールの設定
2. **パフォーマンス**: 効率的なクエリとインデックス
3. **型安全性**: TypeScriptの型システムを活用
4. **エラーハンドリング**: 統一されたエラーハンドリング
5. **リアルタイム**: 適切なリスナーの管理
6. **バッチ操作**: 効率的なバッチ操作の活用

## 💡 実装のヒント

### 1. セキュリティルールの設計
```javascript
// 適切なセキュリティルール
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // ユーザーは自分のデータのみアクセス可能
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // 公開データは読み取り可能
    match /public/{document=**} {
      allow read: if true;
    }
  }
}
```

### 2. 効率的なクエリの作成
```typescript
// 適切なインデックスの使用
const getRecentPosts = async (limit: number = 10) => {
  const q = query(
    collection(db, 'posts'),
    where('published', '==', true),
    orderBy('createdAt', 'desc'),
    limit(limit)
  );
  
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }));
};
```

### 3. 適切なリスナーの管理
```typescript
// コンポーネントでのリスナー管理
export function useRealtimeData<T>(
  collectionName: string,
  queryConstraints: QueryConstraint[] = []
) {
  const data = ref<T[]>([]);
  const loading = ref(false);
  const error = ref<string | null>(null);
  
  let unsubscribe: (() => void) | null = null;
  
  const startListening = () => {
    if (unsubscribe) return;
    
    loading.value = true;
    const q = query(collection(db, collectionName), ...queryConstraints);
    
    unsubscribe = onSnapshot(q, 
      (snapshot) => {
        data.value = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        } as T));
        loading.value = false;
      },
      (err) => {
        error.value = err.message;
        loading.value = false;
      }
    );
  };
  
  const stopListening = () => {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = null;
    }
  };
  
  onUnmounted(() => {
    stopListening();
  });
  
  return { data, loading, error, startListening, stopListening };
}
```

このFirebaseコーディングスタイルに従うことで、セキュアで効率的なFirebaseアプリケーションを構築できます。